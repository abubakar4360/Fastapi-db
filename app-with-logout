from fastapi import FastAPI, Depends, HTTPException, BackgroundTasks
from sqlalchemy.orm import Session
from model import UserTable, TokenTable, EmployeeTable
from schemas import UserCreate, Token, RequestDetails, Employee, ChangePassword, ResetPasswordRequest, ForgotPasswordRequest
from database import SessionLocal
from utils import ALGORITHM, JWT_SECRET_KEY, JWT_REFRESH_SECRET_TOKEN
from utils import get_password_hash, verify_password, create_access_token, create_refresh_token
import jwt
from dotenv import load_dotenv
import os
import smtplib
from fastapi.security import OAuth2PasswordBearer
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime, timedelta
import secrets


load_dotenv()
app = FastAPI()
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

VERIFICATION_SECRET_KEY = secrets.token_hex(32)
VERIFICATION_TOKEN_EXPIRE_MINUTES = 30
RESET_SECRET_KEY = secrets.token_hex(32)

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def verify_token(token: str, db: Session):
    try:
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=ALGORITHM)
        user_id = payload.get("sub")
        if user_id is None:
            raise HTTPException(status_code=401, detail="Invalid token.")

        # Check if the token exists and is valid
        token_entry = db.query(TokenTable).filter(TokenTable.user_id == user_id, TokenTable.access_token == token, TokenTable.is_valid == True).first()
        if not token_entry:
            raise HTTPException(status_code=401, detail="Token is invalid or expired.")

        return payload
    except:
        raise HTTPException(status_code=401, detail="Invalid token.")

def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    payload = verify_token(token, db)
    user_id = payload.get("sub")
    user = db.query(UserTable).filter(UserTable.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=404, detail="User not found.")
    return user

def send_email(subject: str, recipient: str, body: str):
    email = os.getenv("MAIL_USERNAME")
    password = os.getenv("MAIL_PASSWORD")
    smtp_server = os.getenv("MAIL_SERVER")
    port = int(os.getenv("MAIL_PORT"))

    msg = MIMEMultipart()
    msg['From'] = email
    msg['To'] = recipient
    msg['Subject'] = subject
    msg.attach(MIMEText(body, 'plain'))

    try:
        with smtplib.SMTP_SSL(smtp_server, port) if port == 465 else smtplib.SMTP(smtp_server, port) as server:
            if port != 465:
                server.starttls()
            server.login(email, password)
            server.send_message(msg)
            print("Email sent successfully!")
    except Exception as e:
        print(f"Failed to send email: {e}")

@app.post('/register', response_model=UserCreate)
def register_user(register: UserCreate, background_tasks: BackgroundTasks, db: Session = Depends(get_db)):
    # Check for existing user
    already_registered = db.query(UserTable).filter((UserTable.username == register.username) | (UserTable.email == register.email)).first()
    if already_registered:
        raise HTTPException(status_code=400, detail='Username or Email Already registered!')

    # Add new user
    new_user = UserTable(
        first_name=register.first_name,
        last_name=register.last_name,
        username=register.username,
        email=register.email,
        password=get_password_hash(register.password),
        is_verified=False
    )
    db.add(new_user)
    db.commit()
    db.refresh(new_user)

    verification_token = jwt.encode({'sub': new_user.email, 'exp': datetime.utcnow() + timedelta(minutes=30)},
                                    VERIFICATION_SECRET_KEY, algorithm=ALGORITHM)
    verification_link = f"http://127.0.0.1:8000/verify-email?token={verification_token}"

    subject = "Verify Email"
    body = f"Please verify your email by clicking the following link: {verification_link}"

    background_tasks.add_task(send_email, subject, new_user.email, body)

    # return {'message': 'Please verify your email.'}
    return new_user

@app.get('/verify-email')
def verify_email(token: str, db: Session = Depends(get_db)):
    try:
        payload = jwt.decode(token, VERIFICATION_SECRET_KEY, algorithms=ALGORITHM)
        email = payload.get("sub")
        if email is None:
            raise HTTPException(status_code=400, detail="Invalid token.")
    except:
        raise HTTPException(status_code=400, detail="Invalid token.")

    user = db.query(UserTable).filter(UserTable.email == email).first()
    if not user:
        raise HTTPException(status_code=404, detail='Email not found.')

    if user.is_verified:
        return {"message": "Email already verified."}

    user.is_verified = True
    db.commit()

    return {"message": "Verification successful, you can now log in."}


@app.post('/login', response_model=Token)
def login(request: RequestDetails, db: Session = Depends(get_db)):
    user = db.query(UserTable).filter(UserTable.email == request.email).first()
    if user is None:
        raise HTTPException(status_code=400, detail='Username does not exist.')

    if not verify_password(request.password, user.password):
        raise HTTPException(status_code=400, detail='Incorrect Password!')

    if not user.is_verified:
        raise HTTPException(status_code=400, detail='Email not verified.')

    access = create_access_token(user.id)
    refresh = create_refresh_token(user.id)

    token_db = TokenTable(
        user_id=user.id,
        access_token=access,
        refresh_token=refresh,
        status=True
    )

    db.add(token_db)
    db.commit()
    db.refresh(token_db)

    return Token(access_token=access, refresh_token=refresh)


@app.post('/change_password')
def change_password(request: ChangePassword, db: Session = Depends(get_db)):
    user = db.query(UserTable).filter(UserTable.email == request.email).first()
    if not user:
        raise HTTPException(status_code=400, detail='Invalid email.')

    if not verify_password(request.current_password, user.password):
        raise HTTPException(status_code=400, detail='Invalid password.')

    new_password = get_password_hash(request.new_password)
    user.password = new_password
    db.commit()

    return new_password

@app.post('/forget_password')
def forgot_password(request: ForgotPasswordRequest, background_tasks: BackgroundTasks, db: Session = Depends(get_db)):
    user = db.query(UserTable).filter(UserTable.email == request.email).first()
    if not user:
        raise HTTPException(status_code=400, detail='User does not exist.')

    reset_token = jwt.encode({'sub': user.email, 'exp': datetime.utcnow() + timedelta(minutes=30)},
                             RESET_SECRET_KEY, algorithm=ALGORITHM)

    subject = "Reset Password"
    body = f"Use this token to reset the password: {reset_token}"

    background_tasks.add_task(send_email, subject, user.email, body)

    return {"message": "Password reset email has been sent."}


@app.post('/reset_password')
def reset_password(request: ResetPasswordRequest, db: Session = Depends(get_db)):
    try:
        payload = jwt.decode(request.token, RESET_SECRET_KEY, algorithms=ALGORITHM)
        email = payload.get("sub")
        if email is None:
            raise HTTPException(status_code=400, detail="Invalid token.")
    except jwt.PyJWTError:
        raise HTTPException(status_code=400, detail="Invalid token.")

    user = db.query(UserTable).filter(UserTable.email == email).first()
    if not user:
        raise HTTPException(status_code=404, detail='Email not found.')

    user.password = get_password_hash(request.new_password)
    db.commit()

    return {"message": "Password has been reset successfully."}

@app.post('/logout')
def logout_user(request: Token, db: Session = Depends(get_db)):
    try:
        payload = jwt.encode(request.access_token, JWT_SECRET_KEY, algorithm=ALGORITHM)
        user_id = payload['sub']
    except:
        raise HTTPException(status_code=400, detail="Invalid token.")

    tokens = db.query(TokenTable).filter(TokenTable.user_id == user_id,
                                         TokenTable.access_token == request.access_token).all()
    if not tokens:
        raise HTTPException(status_code=404, detail="Token not found.")

    for token in tokens:
        token.is_valid = False
    db.commit()

    return {"message": "Logged out successfully."}

@app.post('/employees', response_model=Employee)
def add_employee(request: Employee, db: Session = Depends(get_db), current_user: UserTable = Depends(get_current_user)):
    employee = db.query(Employee).filter(EmployeeTable.email == request.email).first()
    if employee:
        raise HTTPException(status_code=400, detail='Email already registered.')

    new_employee = EmployeeTable(
            first_name=request.first_name,
            last_name=request.last_name,
            email=request.email,
            job_title=request.job_title,
            manager_id=current_user.id
    )
    db.add(new_employee)
    db.commit()
    db.refresh(new_employee)

    return new_employee
